'''
[编程题] 数字游戏
时间限制：1秒
空间限制：32768K
小易邀请你玩一个数字游戏，小易给你一系列的整数。
你们俩使用这些整数玩游戏。每次小易会任意说一个数字出来，
然后你需要从这一系列数字中选取一部分出来让它们的和等于小易所说的数字。 
例如： 如果{2,1,2,7}是你有的一系列数，小易说的数字是11.你可以得到方案2+2+7 = 11.
如果顽皮的小易想坑你，他说的数字是6，那么你没有办法拼凑出和为6 现在小易给你n个数，
让你找出无法从n个数中选取部分求和的数字中的最小数。 
输入描述:
输入第一行为数字个数n (n ≤ 20)
第二行为n个数xi (1 ≤ xi ≤ 100000)


输出描述:
输出最小不能由n个数选取求和组成的数

输入例子1:
3
5 1 2

输出例子1:
4
'''

'''
解题思路：这题答案很巧妙，虽然代码很短，但思路很难
  1、用basis表示这一系列数组中从0开始能够连续拼凑到的数，例如，[1,2,3,8]数组可以从1连续拼凑出到的数是6，7就不行了
  2、将原数组从小到大重新排序
  3、如果该数的数值小于等于basis+1，那么新的basis为basis加上该数，因为我们可以表示0到basis之间的所有数，
  所以，也能表示该数到该数与basis和之间的所有数
  4、遍历数组中的所有数，如果该数的数值大于basis+1，则表示这个数的值至少比前面所有数的和大2，如[1,2,3,8]中的8，
  比前三个数的和6大2，这意味着这些这个数组无论如何都不能组成7，如果发生这种情况，直接退出循环
  5、最后输出basis+1即可
  
'''

'''
代码运行结果：
答案正确:恭喜！您提交的程序通过了所有的测试用例
'''


n = int(input())
nums = sorted([int(each) for each in input().split()])

basis = 0
for i in range(n):
    if nums[i] > basis + 1:
        break
    else:
        basis += nums[i]

print(basis+1)
